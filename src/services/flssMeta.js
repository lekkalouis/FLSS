import { config } from "../config.js";
import { shopifyFetch } from "./shopify.js";

const META_NAMESPACE = "flss";

const definitionState = {
  metaobjectsEnsured: false,
  metafieldsEnsured: false
};

const refCache = {
  order: new Map(),
  customer: new Map(),
  variant: new Map()
};

const objectCache = {
  flss_sku_master: new Map(),
  flss_customer_profile: new Map(),
  flss_packing_plan: new Map(),
  flss_courier_booking: new Map(),
  flss_dispatch_state: new Map()
};

function graphqlPath() {
  return `/admin/api/${config.SHOPIFY_API_VERSION}/graphql.json`;
}

async function shopifyGraphql(query, variables = {}) {
  const resp = await shopifyFetch(graphqlPath(), {
    method: "POST",
    body: JSON.stringify({ query, variables })
  });
  const text = await resp.text();
  let payload;
  try {
    payload = JSON.parse(text);
  } catch {
    payload = { raw: text };
  }

  if (!resp.ok) {
    throw new Error(`Shopify GraphQL failed (${resp.status}): ${JSON.stringify(payload)}`);
  }
  if (Array.isArray(payload?.errors) && payload.errors.length) {
    throw new Error(`Shopify GraphQL errors: ${JSON.stringify(payload.errors)}`);
  }
  return payload.data || {};
}

function toGid(resource, id) {
  return `gid://shopify/${resource}/${id}`;
}

const metaobjectDefinitions = [
  {
    type: "flss_sku_master",
    name: "FLSS SKU Master",
    access: "MERCHANT_READ_WRITE",
    fieldDefinitions: [
      { key: "sku_code", name: "SKU Code", type: "single_line_text_field", required: true },
      { key: "variant_id", name: "Variant ID", type: "number_integer", required: true },
      { key: "weight_grams", name: "Weight (grams)", type: "number_decimal" },
      { key: "volume_cm3", name: "Volume (cm3)", type: "number_decimal" },
      { key: "packaging_type", name: "Packaging Type", type: "single_line_text_field" },
      { key: "default_box_type", name: "Default Box Type", type: "metaobject_reference" }
    ]
  },
  {
    type: "flss_packing_plan",
    name: "FLSS Packing Plan",
    access: "MERCHANT_READ_WRITE",
    fieldDefinitions: [
      { key: "order_id", name: "Order ID", type: "number_integer", required: true },
      { key: "parcels_json", name: "Parcels JSON", type: "json" },
      { key: "total_weight_kg", name: "Total Weight (kg)", type: "number_decimal" },
      { key: "total_volume_cm3", name: "Total Volume (cm3)", type: "number_decimal" },
      { key: "confidence_score", name: "Confidence Score", type: "number_decimal" },
      { key: "generated_by", name: "Generated By", type: "single_line_text_field" }
    ]
  },
  {
    type: "flss_courier_booking",
    name: "FLSS Courier Booking",
    access: "MERCHANT_READ_WRITE",
    fieldDefinitions: [
      { key: "order_id", name: "Order ID", type: "number_integer", required: true },
      { key: "courier_name", name: "Courier Name", type: "single_line_text_field" },
      { key: "waybill_number", name: "Waybill Number", type: "single_line_text_field" },
      { key: "service_level", name: "Service Level", type: "single_line_text_field" },
      { key: "labels", name: "Labels", type: "list.file_reference" },
      { key: "booking_status", name: "Booking Status", type: "single_line_text_field" }
    ]
  },
  {
    type: "flss_customer_profile",
    name: "FLSS Customer Profile",
    access: "MERCHANT_READ_WRITE",
    fieldDefinitions: [
      { key: "customer_id", name: "Customer ID", type: "number_integer", required: true },
      { key: "tier", name: "Tier", type: "single_line_text_field" },
      { key: "price_group", name: "Price Group", type: "single_line_text_field" },
      { key: "delivery_method", name: "Delivery Method", type: "single_line_text_field" },
      { key: "parcelperfect_place_code", name: "ParcelPerfect Place Code", type: "single_line_text_field" }
    ]
  },
  {
    type: "flss_dispatch_state",
    name: "FLSS Dispatch State",
    access: "MERCHANT_READ_WRITE",
    fieldDefinitions: [
      { key: "order_id", name: "Order ID", type: "number_integer", required: true },
      { key: "lane", name: "Lane", type: "single_line_text_field" },
      { key: "packed", name: "Packed", type: "boolean" },
      { key: "booked", name: "Booked", type: "boolean" },
      { key: "fulfilled", name: "Fulfilled", type: "boolean" },
      { key: "scan_station_state", name: "Scan Station State", type: "json" }
    ]
  }
];

const metafieldDefinitions = [
  { ownerType: "ORDER", key: "packing_plan_ref", type: "metaobject_reference", name: "FLSS Packing Plan Ref" },
  { ownerType: "ORDER", key: "courier_booking_ref", type: "metaobject_reference", name: "FLSS Courier Booking Ref" },
  { ownerType: "ORDER", key: "dispatch_state_ref", type: "metaobject_reference", name: "FLSS Dispatch State Ref" },
  { ownerType: "CUSTOMER", key: "profile_ref", type: "metaobject_reference", name: "FLSS Profile Ref" },
  { ownerType: "PRODUCTVARIANT", key: "sku_master_ref", type: "metaobject_reference", name: "FLSS SKU Master Ref" }
];

async function ensureMetaobjectDefinition(definition) {
  const mutation = `
    mutation EnsureMetaobjectDefinition($definition: MetaobjectDefinitionCreateInput!) {
      metaobjectDefinitionCreate(definition: $definition) {
        metaobjectDefinition { id type }
        userErrors { field message code }
      }
    }
  `;

  const data = await shopifyGraphql(mutation, { definition });
  const errors = data?.metaobjectDefinitionCreate?.userErrors || [];
  const alreadyExists = errors.some((e) => String(e?.message || "").toLowerCase().includes("already exists"));
  if (errors.length && !alreadyExists) {
    throw new Error(`Metaobject definition create failed for ${definition.type}: ${JSON.stringify(errors)}`);
  }
}

async function ensureMetafieldDefinition(definition) {
  const mutation = `
    mutation EnsureMetafieldDefinition($definition: MetafieldDefinitionInput!) {
      metafieldDefinitionCreate(definition: $definition) {
        createdDefinition { id key namespace ownerType }
        userErrors { field message code }
      }
    }
  `;

  const data = await shopifyGraphql(mutation, {
    definition: {
      name: definition.name,
      namespace: META_NAMESPACE,
      key: definition.key,
      ownerType: definition.ownerType,
      type: definition.type
    }
  });

  const errors = data?.metafieldDefinitionCreate?.userErrors || [];
  const alreadyExists = errors.some((e) => String(e?.message || "").toLowerCase().includes("already exists"));
  if (errors.length && !alreadyExists) {
    throw new Error(`Metafield definition create failed for ${definition.ownerType}.${definition.key}: ${JSON.stringify(errors)}`);
  }
}

function sanitizeHandle(value, fallback) {
  const handle = String(value || fallback || "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .slice(0, 120);
  return handle || fallback;
}

function buildMetaFields(input = {}) {
  return Object.entries(input)
    .filter(([, value]) => value !== null && value !== undefined && value !== "")
    .map(([key, value]) => {
      let serialized = value;
      if (typeof value === "boolean") serialized = value ? "true" : "false";
      if (typeof value === "number") serialized = String(value);
      if (typeof value === "object") serialized = JSON.stringify(value);
      return { key, value: String(serialized) };
    });
}

async function metaobjectUpsert({ type, handle, fields }) {
  const mutation = `
    mutation UpsertMetaobject($metaobject: MetaobjectUpsertInput!) {
      metaobjectUpsert(metaobject: $metaobject) {
        metaobject { id handle type }
        userErrors { field message code }
      }
    }
  `;

  const data = await shopifyGraphql(mutation, {
    metaobject: {
      type,
      handle,
      fields
    }
  });

  const errors = data?.metaobjectUpsert?.userErrors || [];
  if (errors.length) {
    throw new Error(`metaobjectUpsert failed for ${type}/${handle}: ${JSON.stringify(errors)}`);
  }

  return data?.metaobjectUpsert?.metaobject || null;
}

export async function ensureMetaobjectDefinitions() {
  if (definitionState.metaobjectsEnsured) return;
  for (const def of metaobjectDefinitions) {
    await ensureMetaobjectDefinition(def);
  }
  definitionState.metaobjectsEnsured = true;
}

export async function ensureMetafieldDefinitions() {
  if (definitionState.metafieldsEnsured) return;
  for (const def of metafieldDefinitions) {
    await ensureMetafieldDefinition(def);
  }
  definitionState.metafieldsEnsured = true;
}

export async function upsertSkuMaster(variant = {}) {
  if (!variant?.id) return null;
  await ensureMetaobjectDefinitions();
  const handle = sanitizeHandle(variant.sku || `variant-${variant.id}`, `variant-${variant.id}`);
  const fields = buildMetaFields({
    sku_code: variant.sku || `variant-${variant.id}`,
    variant_id: Number(variant.id),
    weight_grams: Number(variant.weight_grams ?? variant.grams ?? 0) || undefined,
    volume_cm3: Number(variant.volume_cm3 ?? 0) || undefined,
    packaging_type: variant.packaging_type || undefined
  });

  const obj = await metaobjectUpsert({ type: "flss_sku_master", handle, fields });
  if (obj?.id) objectCache.flss_sku_master.set(String(variant.id), obj.id);
  return obj;
}

export async function createPackingPlan(orderId, packingData = {}) {
  if (!orderId) return null;
  await ensureMetaobjectDefinitions();
  const handle = sanitizeHandle(`order-${orderId}`);
  const fields = buildMetaFields({
    order_id: Number(orderId),
    parcels_json: packingData.parcels_json ?? packingData.parcels ?? {},
    total_weight_kg: packingData.total_weight_kg,
    total_volume_cm3: packingData.total_volume_cm3,
    confidence_score: packingData.confidence_score,
    generated_by: packingData.generated_by || "flss-scan-station"
  });

  const obj = await metaobjectUpsert({ type: "flss_packing_plan", handle, fields });
  if (obj?.id) objectCache.flss_packing_plan.set(String(orderId), obj.id);
  return obj;
}

export async function createCourierBooking(orderId, bookingData = {}) {
  if (!orderId) return null;
  await ensureMetaobjectDefinitions();
  const handle = sanitizeHandle(`order-${orderId}`);
  const fields = buildMetaFields({
    order_id: Number(orderId),
    courier_name: bookingData.courier_name,
    waybill_number: bookingData.waybill_number,
    service_level: bookingData.service_level,
    labels: bookingData.labels,
    booking_status: bookingData.booking_status || "pending"
  });

  const obj = await metaobjectUpsert({ type: "flss_courier_booking", handle, fields });
  if (obj?.id) objectCache.flss_courier_booking.set(String(orderId), obj.id);
  return obj;
}

export async function upsertCustomerProfile(customerId, profileData = {}) {
  if (!customerId) return null;
  await ensureMetaobjectDefinitions();
  const handle = sanitizeHandle(`customer-${customerId}`);
  const fields = buildMetaFields({
    customer_id: Number(customerId),
    tier: profileData.tier,
    price_group: profileData.price_group,
    delivery_method: profileData.delivery_method,
    parcelperfect_place_code: profileData.parcelperfect_place_code
  });

  const obj = await metaobjectUpsert({ type: "flss_customer_profile", handle, fields });
  if (obj?.id) objectCache.flss_customer_profile.set(String(customerId), obj.id);
  return obj;
}

export async function createDispatchState(orderId, dispatchData = {}) {
  if (!orderId) return null;
  await ensureMetaobjectDefinitions();
  const handle = sanitizeHandle(`order-${orderId}`);
  const fields = buildMetaFields({
    order_id: Number(orderId),
    lane: dispatchData.lane,
    packed: dispatchData.packed,
    booked: dispatchData.booked,
    fulfilled: dispatchData.fulfilled,
    scan_station_state: dispatchData.scan_station_state ?? dispatchData
  });

  const obj = await metaobjectUpsert({ type: "flss_dispatch_state", handle, fields });
  if (obj?.id) objectCache.flss_dispatch_state.set(String(orderId), obj.id);
  return obj;
}

export async function linkMetaobjectToResource(resourceType, resourceId, metafieldKey, metaobjectId) {
  if (!resourceType || !resourceId || !metafieldKey || !metaobjectId) return null;
  await ensureMetafieldDefinitions();

  const ownerGid =
    resourceType === "order"
      ? toGid("Order", resourceId)
      : resourceType === "customer"
        ? toGid("Customer", resourceId)
        : resourceType === "variant"
          ? toGid("ProductVariant", resourceId)
          : null;

  if (!ownerGid) throw new Error(`Unsupported resourceType: ${resourceType}`);

  const mutation = `
    mutation LinkMetaobject($metafields: [MetafieldsSetInput!]!) {
      metafieldsSet(metafields: $metafields) {
        metafields { id key namespace value }
        userErrors { field message code }
      }
    }
  `;

  const data = await shopifyGraphql(mutation, {
    metafields: [
      {
        ownerId: ownerGid,
        namespace: META_NAMESPACE,
        key: metafieldKey,
        type: "metaobject_reference",
        value: metaobjectId
      }
    ]
  });

  const errors = data?.metafieldsSet?.userErrors || [];
  if (errors.length) {
    throw new Error(`metafieldsSet failed for ${resourceType}/${resourceId}/${metafieldKey}: ${JSON.stringify(errors)}`);
  }

  refCache[resourceType]?.set(String(resourceId), { [metafieldKey]: metaobjectId });
  return data?.metafieldsSet?.metafields?.[0] || null;
}

export function getCachedMetaobjectId(type, ownerId) {
  return objectCache[type]?.get(String(ownerId)) || null;
}
